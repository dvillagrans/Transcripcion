import { JobService } from './JobService.js';
import redisClient from '../config/redis.js';
import { JobProgress } from '../models/Job.js';
import fs from 'fs/promises';
import path from 'path';
import axios from 'axios';

export class AudioProcessingService {
  private static progressMap = new Map<string, JobProgress>();
  private static readonly TRANSCRIPTION_SERVICE_URL = process.env.TRANSCRIPTION_SERVICE_URL || 'http://localhost:5000';

  static async processAudio(jobId: string, filePath: string, options: {
    whisperModel?: string;
    language?: string;
    generateSummary?: boolean;
  } = {}): Promise<void> {
    try {
      // Update job status to processing
      await JobService.updateJob(jobId, { status: 'processing' });
      
      // Set initial progress
      this.setProgress(jobId, 10, 'Iniciando procesamiento');
      
      // Check if transcription service is available
      const isServiceAvailable = await this.checkTranscriptionService();
      console.log(`Processing job ${jobId}: service available = ${isServiceAvailable}, generateSummary = ${options.generateSummary}`);
      
      if (isServiceAvailable) {
        // Use real transcription service
        await this.transcribeWithFasterWhisper(jobId, filePath, options);
      } else {
        console.warn('Transcription service not available, falling back to simulation');
        await this.simulateTranscription(jobId, filePath);
      }
      
      // Generate summary if requested
      if (options.generateSummary) {
        if (isServiceAvailable) {
          console.log(`Summary was requested and service is available - summary should have been generated by the Python service`);
          // El resumen ya deber√≠a haber sido generado por el servicio Python en transcribeWithFasterWhisper
          // No necesitamos hacer nada adicional aqu√≠
        } else {
          console.log(`Summary was requested but service is not available - using simulation`);
          this.setProgress(jobId, 80, 'Generando resumen (simulaci√≥n)');
          await this.simulateSummaryGeneration(jobId);
        }
      }
      
      // Complete processing
      this.setProgress(jobId, 100, 'Completado');
      await JobService.updateJob(jobId, { status: 'completed' });
      
      // Clean up progress
      this.progressMap.delete(jobId);
      
    } catch (error) {
      console.error(`Error processing audio for job ${jobId}:`, error);
      await JobService.updateJob(jobId, { status: 'error' });
      this.progressMap.delete(jobId);
    }
  }

  private static async checkTranscriptionService(): Promise<boolean> {
    try {
      const response = await axios.get(`${this.TRANSCRIPTION_SERVICE_URL}/health`, {
        timeout: 5000
      });
      return response.status === 200;
    } catch (error) {
      console.warn('Transcription service health check failed:', (error as Error).message);
      return false;
    }
  }

  private static async transcribeWithFasterWhisper(jobId: string, filePath: string, options: {
    whisperModel?: string;
    language?: string;
    generateSummary?: boolean;
  }): Promise<void> {
    try {
      this.setProgress(jobId, 20, 'Conectando con servicio de transcripci√≥n');
      
      // Prepare transcription request
      const transcriptionRequest = {
        file_path: path.resolve(filePath),
        model: options.whisperModel || 'large-v3', // Usar large-v3 que ya est√° precargado
        language: options.language || 'es', // Espa√±ol por defecto
        generate_summary: options.generateSummary || false,
        job_id: jobId // ¬°IMPORTANTE! Pasar job_id para tracking de progreso
      };
      
      this.setProgress(jobId, 30, 'Enviando archivo para transcripci√≥n');
      
      // Para archivos largos, usar timeout extendido din√°micamente
      let response;
      try {
        const fs = await import('fs/promises');
        const fileStats = await fs.stat(filePath);
        const fileSizeMB = fileStats.size / (1024 * 1024);
        
        // Calcular timeout basado en tama√±o del archivo
        // Aproximadamente 1 minuto de processing por cada 10 minutos de audio
        let timeoutMs = 600000; // 10 minutos por defecto
        
        if (fileSizeMB > 50) { // Archivos grandes (>50MB probablemente >30min)
          timeoutMs = 1800000; // 30 minutos
        }
        if (fileSizeMB > 200) { // Archivos muy grandes (>200MB probablemente >1h)
          timeoutMs = 3600000; // 60 minutos
        }
        
        console.log(`üïí Timeout configurado para ${timeoutMs/1000/60} minutos para archivo de ${fileSizeMB.toFixed(1)}MB`);
        
        // Call transcription service
        response = await axios.post(
          `${this.TRANSCRIPTION_SERVICE_URL}/transcribe`,
          transcriptionRequest,
          {
            timeout: timeoutMs,
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );
      } catch (fsError) {
        console.log('‚ö†Ô∏è No se pudo determinar el tama√±o del archivo, usando timeout est√°ndar');
        // Fallback con timeout m√°s largo por defecto
        response = await axios.post(
          `${this.TRANSCRIPTION_SERVICE_URL}/transcribe`,
          transcriptionRequest,
          {
            timeout: 1800000, // 30 minutos por defecto
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );
      }
      
      const result = response.data;
      
      if (result.success) {
        this.setProgress(jobId, 70, 'Procesando resultados de transcripci√≥n');
        
        console.log(`‚úÖ Transcription response received for job ${jobId}:`, {
          hasTranscription: !!result.transcription,
          transcriptionLength: result.transcription?.length || 0,
          hasSummary: !!result.summary,
          summaryLength: result.summary?.length || 0,
          duration: result.duration,
          processingTime: result.processing_time
        });
        
        // Update job with transcription results
        const updateData: any = {
          transcription: result.transcription
        };
        
        if (result.summary) {
          console.log(`Summary received from Python service for job ${jobId}:`, result.summary.substring(0, 100) + '...');
          updateData.summary = result.summary;
        } else {
          console.log(`No summary received from Python service for job ${jobId}`);
        }
        
        console.log(`üîÑ Updating database for job ${jobId} with:`, {
          transcriptionLength: updateData.transcription?.length || 0,
          summaryLength: updateData.summary?.length || 0
        });
        
        const updateResult = await JobService.updateJob(jobId, updateData);
        
        if (updateResult) {
          console.log(`‚úÖ Job ${jobId} updated successfully in database`);
        } else {
          console.error(`‚ùå Failed to update job ${jobId} in database`);
        }
        
        console.log(`Transcription completed for job ${jobId}:`, {
          duration: result.duration,
          processing_time: result.processing_time,
          language: result.language,
          segments_count: result.segments_count,
          model_used: result.model_used
        });
        
      } else {
        throw new Error(result.error || 'Transcription failed');
      }
      
    } catch (error) {
      console.error('‚ùå Error in faster-whisper transcription:', error);
      console.error('‚ùå Error details:', {
        jobId,
        message: (error as Error).message,
        stack: (error as Error).stack,
        response: (error as any).response?.data
      });
      
      // Fallback to simulation if real transcription fails
      console.log('Falling back to simulation...');
      await this.simulateTranscription(jobId, filePath);
    }
  }

  private static async simulateTranscription(jobId: string, filePath: string): Promise<void> {
    // Simulate transcription process
    for (let i = 20; i <= 70; i += 10) {
      this.setProgress(jobId, i, 'Transcribiendo audio (simulaci√≥n)');
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    // Mock transcription result
    const mockTranscription = `Transcripci√≥n simulada del archivo de audio. 
    Este es un ejemplo de texto transcrito que incluye m√∫ltiples oraciones 
    y p√°rrafos para demostrar el funcionamiento del sistema de procesamiento 
    de audio. El archivo original era: ${path.basename(filePath)}.`;
    
    await JobService.updateJob(jobId, { transcription: mockTranscription });
  }

  private static async simulateSummaryGeneration(jobId: string): Promise<void> {
    // Simulate summary generation
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const job = await JobService.getJobById(jobId);
    if (job && job.transcription) {
      const mockSummary = `Resumen autom√°tico: El audio contiene informaci√≥n relevante 
      sobre el tema principal. Se identificaron conceptos clave y puntos importantes 
      que fueron extra√≠dos del contenido transcrito.`;
      
      await JobService.updateJob(jobId, { summary: mockSummary });
    }
  }

  static setProgress(jobId: string, progress: number, currentStage: string): void {
    const jobProgress: JobProgress = {
      jobId,
      progress,
      currentStage,
      status: progress === 100 ? 'completed' : 'processing'
    };
    
    this.progressMap.set(jobId, jobProgress);
    
    // Store in Redis for persistence
    redisClient.setEx(`progress:${jobId}`, 3600, JSON.stringify(jobProgress))
      .catch(err => console.error('Redis error:', err));
  }

  static async getProgress(jobId: string): Promise<JobProgress | null> {
    // Try to get from memory first
    const memoryProgress = this.progressMap.get(jobId);
    if (memoryProgress) {
      return memoryProgress;
    }

    // Try to get from Redis
    try {
      const redisProgress = await redisClient.get(`progress:${jobId}`);
      if (redisProgress) {
        const parsedProgress = JSON.parse(redisProgress);
        // Store in memory for faster subsequent access
        this.progressMap.set(jobId, parsedProgress);
        return parsedProgress;
      }
    } catch (error) {
      console.error('Error getting progress from Redis:', error);
    }

    // If not found in memory or Redis, try to get from Python transcription service
    try {
      const isServiceAvailable = await this.checkTranscriptionService();
      if (isServiceAvailable) {
        const response = await axios.get(`${this.TRANSCRIPTION_SERVICE_URL}/progress/${jobId}`, {
          timeout: 5000
        });
        
        if (response.data.success && response.data.progress) {
          const progressData: JobProgress = {
            jobId: jobId,
            progress: response.data.progress.progress || 0,
            currentStage: response.data.progress.current_stage || 'Procesando',
            status: response.data.progress.status || 'processing'
          };
          
          // Store in memory and Redis
          this.progressMap.set(jobId, progressData);
          try {
            await redisClient.setex(`progress:${jobId}`, 300, JSON.stringify(progressData)); // 5 min TTL
          } catch (redisError) {
            console.error('Error storing progress in Redis:', redisError);
          }
          
          return progressData;
        }
      }
    } catch (error) {
      console.error('Error getting progress from transcription service:', error);
    }

    return null;
  }

  static async generateSummaryForJob(jobId: string): Promise<void> {
    try {
      // Get job with transcription
      const job = await JobService.getJobById(jobId);
      if (!job || !job.transcription) {
        throw new Error('No transcription found for job');
      }

      console.log(`Generating summary for job ${jobId}`);
      this.setProgress(jobId, 10, 'Iniciando generaci√≥n de resumen');

      // Check if transcription service is available
      const isServiceAvailable = await this.checkTranscriptionService();
      
      if (isServiceAvailable) {
        // Try to generate summary using the Python service
        try {
          const response = await axios.post(`${this.TRANSCRIPTION_SERVICE_URL}/generate_summary`, {
            text: job.transcription
          });
          
          this.setProgress(jobId, 80, 'Procesando resumen con IA');
          
          if (response.data.success && response.data.summary) {
            // Update job with the generated summary
            await JobService.updateJob(jobId, { 
              summary: response.data.summary 
            });
            this.setProgress(jobId, 100, 'Resumen completado');
            console.log(`Summary generated successfully for job ${jobId}`);
          } else {
            throw new Error('Summary generation failed');
          }
        } catch (error) {
          console.error('Error generating summary with Python service:', error);
          // Fall back to simulation
          await this.simulateSummaryGeneration(jobId);
        }
      } else {
        console.log('Transcription service not available, using simulation');
        await this.simulateSummaryGeneration(jobId);
      }
    } catch (error) {
      console.error(`Error generating summary for job ${jobId}:`, error);
      this.setProgress(jobId, 0, 'Error al generar resumen');
      throw error;
    }
  }

  static async cleanupFile(filePath: string): Promise<void> {
    try {
      await fs.unlink(filePath);
      console.log(`Cleaned up file: ${filePath}`);
    } catch (error) {
      console.error(`Error cleaning up file ${filePath}:`, error);
    }
  }
}